#include <iostream>
#include <fstream>
#include <armadillo>
#include <experimental/random>
#include <algorithm>
#include <boost/archive/text_oarchive.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/filesystem.hpp>
#include <sstream>
//#include <boost/parameter/keyword.hpp>
//namespace parameter = boost::parameter;

#include <ctime>

using namespace std;
using namespace arma;

struct Params {
	int n_users;
	float p_inf;
	mat p_infvec;
	float p_inf0;
	float avg_deg;
	float avg_deg_ER; // Only used when generating cluster network
	int dt;
	int timesteps;
	float p_own;
	float p_other;
	string p_infdist;
	string networktype;
	float alpha;
	string basedir;
	float initrec;
	float a_mean;
	string act_dist;
	float alpha_act;
	mat p_susvec;
	string p_susdist;
	float alpha_sus;
	mat a_vec; // Activity vector
	string vacc_scheme;
};

struct Edgelist_and_neighbordict { // Declare a structure
	vector<vector<int>> el; // For returning edgelist
	map<int, vector<int> > nd; // For returning neighbordict
};


struct InfectionTree {
	int t_infected;
	int t_symptom;
	int infected_by;
	vector<int> users_infected;
};

void print_intvec(std::vector<int> const &input)
{
	for (int i = 0; i < input.size(); i++) {
		std::cout << input.at(i) << ' ';
	}
	std::cout << endl;
}

auto draw_single_infectivity(float p_inf, string inf_dist, float alpha, bool warn) {
	random_device rd;
    mt19937 gen(rd());
	exponential_distribution<> d(1.0/p_inf);
	float p;
	// Note: The mean of the gamma distribution is alpha * beta.
	// Since we want mean = p_inf, we set beta = p_inf/alpha.
	float beta = p_inf/alpha;
	gamma_distribution<> g(alpha, beta);
	if (inf_dist == "exp") {
		p = d(gen);
		if (p > 1 && warn) {
			cout << "WARNING: Infection probability exceeds 1." << endl;
		}
	}
	if (inf_dist == "gamma") {
		p = g(gen);
		if (p > 1 && warn) {
			cout << "WARNING: Infection probability exceeds 1." << endl;
		}
	}
	else if (inf_dist == "step") {
		float r = randu();
		if (r < p_inf) {
			p = 1.0;
		}
		else {
			p = 0.0;
		}
	}
	else if (inf_dist == "flat" || inf_dist == "delta") {
		p = p_inf;
	}
	else {
		cout << "Error, no distribution chosen" << endl;
		p = 0.0;
	}
	return p;
}

auto generate_infectivities(int num_nodes, umat vars, mat var_alpha, mat var_pinf, string inf_dist, bool warn) {
	mat p_infvec(1,num_nodes,fill::zeros);
	for ( int i = 0; i < num_nodes; i++) {
		if (vars[i] > 0) {
			float alpha = var_alpha[vars[i]-1]; // Variants are not 0-indexed ...
			float pinfmean = var_pinf[vars[i]-1];
			p_infvec[i] = draw_single_infectivity(pinfmean, inf_dist, alpha, warn);
		} else {
			p_infvec[i] = 0.0;
		}
	}
	cout << "Mean: " << accu(p_infvec)/num_nodes << endl;
	cout << "Max: " << p_infvec.max() << endl;
	return p_infvec;
}

auto generate_susceptibilities(int num_nodes, mat p_inf0_vec, string inf_dist, mat alpha_vec, bool warn) {
	mat p_infvec(1,num_nodes,fill::zeros);
	for ( int i = 0; i < num_nodes; i++) {
		p_infvec[i] = draw_single_infectivity(p_inf0_vec[i], inf_dist, alpha_vec[i], warn);
	}
	cout << "Mean: " << accu(p_infvec)/num_nodes << endl;
	cout << "Max: " << p_infvec.max() << endl;
	return p_infvec;
}

auto generate_activities(int num_nodes, float a_mean, string act_dist, float alpha_act) {
	mat a_vec(1,num_nodes,fill::zeros);
	random_device rd;
    mt19937 gen(rd());
	exponential_distribution<> d(1.0/a_mean);
	// Note: The mean of the gamma distribution is alpha * beta.
	// Since we want mean = a_mean, we set beta = a_mean/alpha_act.
	float beta = a_mean/alpha_act;
	gamma_distribution<> g(alpha_act, beta);
	for ( int i = 0; i < num_nodes; i++) {
		if (act_dist == "exp") {
			a_vec[i] = d(gen);
		}
		if (act_dist == "gamma") {
			a_vec[i] = g(gen);
		}
		else if (act_dist == "step") {
			float r = randu();
			if (r < a_mean) {
				a_vec[i] = 1.0;
			}
			else {
				a_vec[i] = 0.0;
			}
		}
		else if (act_dist == "delta") {
			a_vec[i] = a_mean;
		}
		else {
			cout << "Warning, no activity distribution chosen, assuming delta distribution" << endl;
			a_vec[i] = a_mean;
		}
	}
	cout << endl;
	cout << "Mean activity: " << mean(a_vec,1);
	cout << "Max activity: " << a_vec.max() << endl;
	cout << "Coefficient of activity variation: " << stddev(a_vec,0,1)/mean(a_vec,1) << endl;
	return a_vec;
}

auto generate_groups_network(int num_nodes, float avg_deg, int memberships)
{
	// Initiate the vector which is to hold the list of edges in the network
	vector<vector<int>> edgelist;
	// Next, initiate the neighbordict, which is supposed to work like this (pseudo-code):
	// neighbordict[1] = [2,43,6] and so on ...
	map<int, vector<int> > neighbordict;
	// groupdict works similarly, with the i'th element being a vector containing
	// the IDs of members of the i'th group.
	map<int, vector<int> > groupdict;
	// Number of groups:
	// Formula for deterministic group size case:
	//float S_grp = avg_deg/((float)memberships) +1; // Group size
	// Formula for Poisson group size case:
	float S_grp = avg_deg/((float)memberships); // Group size
	int num_groups = round(memberships*num_nodes/S_grp);
	cout << "Number of groups: " << num_groups << endl;
	// We place people in $memberships$ different groups simply by going through
	// all agents $memberships$ times,
	// placing them in /some/ group both times around. Of course we will have to
	// check that they are not /already/ member of that group (however unlikely
	// that is ... )
	for (int i=0; i < memberships; i++)
	{
		for (int agent=0; agent < num_nodes; agent++)
		{
			bool placed;
			placed = false;
			while (!placed)
			{
				// Randomly choose next group:
				int group_id = (rand() % num_groups);
				// Deterministically choose next group:
				//int group_id = ((agent+i) % num_groups);
				if (count(groupdict[group_id].begin(), groupdict[group_id].end(), agent) == 0) {
					groupdict[group_id].push_back(agent);
					placed = true;
				}
			}
		}
	}
	// Report the average group size:
	int s_sum = 0;
	for (int i=0; i < num_groups; i++)
	{
		s_sum = s_sum + groupdict[i].size();
	}
	cout << "Average group size: " << (float)s_sum/((float)num_groups) << endl;
	// Then we must translate the group memberships (groupdict) into an
	// edgelist and a neighbordict
	for (int group_id = 0; group_id < num_groups; group_id++)
	{
		if (!groupdict[group_id].empty())
		{
			for (int i : groupdict[group_id])
			{
				if (i > num_nodes) // Sanity check
				{
					cout << "Warning, illegal node encountered in generate_groups_network()" << endl;
				}
				for (int j : groupdict[group_id])
				{
					int src = i;
					int dst = j;
					//cout << "src:dst=" << src << ":" << dst << endl;
					vector<int> new_edge_forward;
					vector<int> new_edge_backward;
					new_edge_forward.push_back(src);
					new_edge_forward.push_back(dst);
					new_edge_backward.push_back(dst);
					new_edge_backward.push_back(src);
					if (count(neighbordict[src].begin(), neighbordict[src].end(), dst) == 0) // (src,dst) wasn't found in the edgelist, so we can add the link.
					{
						if (i != j) // No self-linmembershipsks!
						{
							// Add edges to the edgelist (which is in fact a vector):
							edgelist.emplace_back(new_edge_forward);
							edgelist.emplace_back(new_edge_backward);
							// Add edges to the edgedict as well - it's double book-keeping, but it
							// simplifies things to be able to look up edges by the user ID
							neighbordict[new_edge_forward[0]].emplace_back(new_edge_forward[1]);
							neighbordict[new_edge_backward[0]].emplace_back(new_edge_backward[1]);
						}
					}
				}
			}
		}
	}
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
}

auto configuration_model(umat degrees) { // 'degrees' is the sequence of degrees!
	// Initiate the vector which is to hold the list of edges in the network
	vector<vector<int>> edgelist;
	//umat stubs(1, accu(degrees), fill::zeros);
	vector<int> stubs;
	//list<int> stubs;
	if (accu(degrees) % 2 != 0)
	{ // Sum of degrees must be even for the algorithm to work. Increment by 1 if odd.
		degrees[0]++;
	}
	int num_nodes = degrees.size();
	int degsum = 0;
	for (int i=0; i < degrees.size(); i++)
	{
		for (int j=0; j < degrees[i]; j++ )
		{
			stubs.push_back(i);
			degsum++;
		}
	}
	// Randomize the stubs vector:
	random_shuffle(stubs.begin(), stubs.end());
	// Next, initiate the neighbordict, which is supposed to work like this (pseudo-code):
	// neighbordict[1] = [2,43,6]
	map<int, vector<int> > neighbordict;
	while (stubs.size() > 1)
	{
		int src;
		int dst;
		src = stubs.back();
		stubs.pop_back();
		dst = stubs.back();
		stubs.pop_back();
		vector<int> new_edge_forward;
		vector<int> new_edge_backward;
		new_edge_forward.push_back(src);
		new_edge_forward.push_back(dst);
		new_edge_backward.push_back(dst);
		new_edge_backward.push_back(src);
		if (count(neighbordict[src].begin(), neighbordict[src].end(), dst) == 0) // (src,dst) wasn't found in the edgelist, so we can add the link.
		{
			// Add edges to the edgelist (which is in fact a vector):
			edgelist.emplace_back(new_edge_forward);
			edgelist.emplace_back(new_edge_backward);
			// Add edges to the edgedict as well - it's double book-keeping, but it
			// simplifies things to be able to look up edges by the user ID
			neighbordict[new_edge_forward[0] ].emplace_back(new_edge_forward[1]);
			neighbordict[new_edge_backward[0] ].emplace_back(new_edge_backward[1]);
		}
	}
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
}

auto gen_exp_network(int num_nodes, float avg_deg) {
	umat degrees(1, num_nodes, fill::zeros);
	random_device rd;
  	mt19937 gen(rd());
	exponential_distribution<> d(1.0/avg_deg);
	for (int i = 0; i < num_nodes; i++)
	{
		degrees[i] = round(d(gen));
	}
	auto [edgelist, neighbordict] = configuration_model(degrees);
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
}

auto gen_pow_network(int num_nodes, float avg_deg) {
	int avg_deg_int = int(avg_deg);
	umat degrees(1, num_nodes, fill::zeros);
	random_device rd;
	mt19937 gen(rd());
	vector<float> p_list_full = {0.000000000000000000e+00,1.945871685014163854e-02,2.647141887033398200e-02,2.843731651039476185e-02,2.824529027090022862e-02,2.713078306769911227e-02,2.565440000527822312e-02,2.407893361636715204e-02,2.252806708601644281e-02,2.105788476469803300e-02,1.969083698903837526e-02,1.843253439797761309e-02,1.728029957060618280e-02,1.622760448329797420e-02,1.526639017590225751e-02,1.438827051455340497e-02,1.358513849832770036e-02,1.284945014946146935e-02,1.217433476332707883e-02,1.155361312977159702e-02,1.098176885732600819e-02,1.045389778357817476e-02,9.965649186315388500e-03,9.513166156526274564e-03,9.093028901947249054e-03,8.702202726367458396e-03,8.337991305055764829e-03,7.997995268548526229e-03,7.680075795749630868e-03,7.382322775250163734e-03,7.103027046592496827e-03,6.840656237483648712e-03,6.593833743483953555e-03,6.361320438954746852e-03,6.141998753871395073e-03,5.934858796059180701e-03,5.738986240243037877e-03,5.553551743038438390e-03,5.377801676386123955e-03,5.211050001072138962e-03,5.052671127195708725e-03,4.902093630151828883e-03,4.758794709302813751e-03,4.622295292427623138e-03,4.492155702630827065e-03,4.367971815996634852e-03,4.249371648178475354e-03,4.136012316573331460e-03,4.027577331959195442e-03,3.923774179658190767e-03,3.824332155584871107e-03,3.729000427081943271e-03,3.637546292347407749e-03,3.549753615613382863e-03,3.465421418128482138e-03,3.384362607490970856e-03,3.306402830036907214e-03,3.231379432855057288e-03,3.159140523620104692e-03,3.089544117842838843e-03,3.022457364360502802e-03,2.957755840957815383e-03,2.895322912941061377e-03,2.835049148302576458e-03,2.776831783826768686e-03,2.720574237115046690e-03,2.666185660057319301e-03,2.613580529761933002e-03,2.562678273382786552e-03,2.513402923659050804e-03,2.465682802315996482e-03,2.419450228770223758e-03,2.374641251843975179e-03,2.331195402425224970e-03,2.289055465216495878e-03,2.248167267898969635e-03,2.208479486202075300e-03,2.169943463514825612e-03,2.132513043805634410e-03,2.096144416734157037e-03,2.060795973943245311e-03,2.026428175612959761e-03,1.993003426442777060e-03,1.960485960303863864e-03,1.928841732871434478e-03,1.898038321608579940e-03,1.868044832528352808e-03,1.838831813210860819e-03,1.810371171597324963e-03,1.782636100123922377e-03,1.755601004795267128e-03,1.729241438830946475e-03,1.703534040548973505e-03,1.678456475177699967e-03,1.653987380312861924e-03,1.630106314759329367e-03,1.606793710517973907e-03,1.584030827697059706e-03,1.561799712144910533e-03,1.540083155616427547e-03,1.518864658300507616e-03,1.498128393548638386e-03,1.477859174657066357e-03,1.458042423566029795e-03,1.438664141349725416e-03,1.419710880380010238e-03,1.401169718055425084e-03,1.383028231994988229e-03,1.365274476603468585e-03,1.347896960921505247e-03,1.330884627680087653e-03,1.314226833484563421e-03,1.297913330058560492e-03,1.281934246483036870e-03,1.266280072370092611e-03,1.250941641915322101e-03,1.235910118776250557e-03,1.221176981727938125e-03,1.206734011050078492e-03,1.192573275602928006e-03,1.178687120552215006e-03,1.165068155705743878e-03,1.151709244426837603e-03,1.138603493091977807e-03,1.125744241062087096e-03,1.113125051138818189e-03,1.100739700479018207e-03,1.088582171942191002e-03,1.076646645847349889e-03,1.064927492117089718e-03,1.053419262788061160e-03,1.042116684868288215e-03,1.031014653522941294e-03,1.020108225571275673e-03,1.009392613278473592e-03,9.988631784270697849e-04,9.885154266535552906e-04,9.783450020365684358e-04,9.683476819238815564e-04,9.585193719861160797e-04,9.488561014858015166e-04,9.393540187510462805e-04,9.300093868436820664e-04,9.208185794123098034e-04,9.117780767212104636e-04,9.028844618465720106e-04,8.941344170319624448e-04,8.855247201954049956e-04,8.770522415808351072e-04,8.687139405470969272e-04,8.605068624880097541e-04,8.524281358773719806e-04,8.444749694330934853e-04,8.366446493949556643e-04,8.289345369107781279e-04,8.213420655260473408e-04,8.138647387723107682e-04,8.065001278498833831e-04,7.992458694006402070e-04,7.920996633668775898e-04,7.850592709324326910e-04,7.781225125424372181e-04,7.712872659982619944e-04,7.645514646243796930e-04,7.579130955040331002e-04,7.513701977807460018e-04,7.449208610228614516e-04,7.385632236484233719e-04,7.322954714078502500e-04,7.261158359219676553e-04,7.200225932730842634e-04,7.140140626469036267e-04,7.080886050231676885e-04,7.022446219130282176e-04,6.964805541412304873e-04,6.907948806712882819e-04,6.851861174719056386e-04,6.796528164229875824e-04,6.741935642596517128e-04,6.688069815527265555e-04,6.634917217242914354e-04,6.582464700968742146e-04,6.530699429749889373e-04,6.479608867577492035e-04,6.429180770813520702e-04,6.379403179902784580e-04,6.330264411361064512e-04,6.281753050028819141e-04,6.233857941580369212e-04,6.186568185278868348e-04,6.139873126967844560e-04,6.093762352290397121e-04,6.048225680127615857e-04,6.003253156248036055e-04,5.958835047160384538e-04,5.914961834162110960e-04,5.871624207576576788e-04,5.828813061172012948e-04,5.786519486755683454e-04,5.744734768936933045e-04,5.703450380053053798e-04,5.662657975252185409e-04,5.622349387727639501e-04,5.582516624098313651e-04,5.543151859930049545e-04,5.504247435392996702e-04,5.465795851050239467e-04,5.427789763773135804e-04,5.390221982778983355e-04,5.353085465786815850e-04,5.316373315287277078e-04,5.280078774922692102e-04,5.244195225973589773e-04,5.208716183948091088e-04,5.173635295270699380e-04,5.138946334067170333e-04,5.104643199042243912e-04,5.070719910447188351e-04,5.037170607134155119e-04,5.003989543694519447e-04,4.971171087678440603e-04,4.938709716892989961e-04,4.906600016776319594e-04,4.874836677845384219e-04,4.843414493214874095e-04,4.812328356185064130e-04,4.781573257896380475e-04,4.751144285048571991e-04,4.721036617682441289e-04,4.691245527022147956e-04,4.661766373376212674e-04,4.632594604095367666e-04,4.603725751585479209e-04,4.575155431373867094e-04,4.546879340227331858e-04,4.518893254320329616e-04,4.491193027451758192e-04,4.463774589308851281e-04,4.436633943776772818e-04,4.409767167292527037e-04,4.383170407241830028e-04,4.356839880397681344e-04,4.330771871399369840e-04,4.304962731270717876e-04,4.279408875976401612e-04,4.254106785015221459e-04,4.229053000049234684e-04,4.204244123567703914e-04,4.179676817584839681e-04,4.155347802370359055e-04,4.131253855211908981e-04,4.107391809208434910e-04,4.083758552093606233e-04,4.060351025088435473e-04,4.037166221782261845e-04,4.014201187041293055e-04,3.991453015943922564e-04,3.968918852742073667e-04,3.946595889847827701e-04,3.924481366844642508e-04,3.902572569522465631e-04,3.880866828936086290e-04,3.859361520486069672e-04,3.838054063021669078e-04,3.816941917965099027e-04,3.796022588456587086e-04,3.775293618519639030e-04,3.754752592245971972e-04,3.734397132999574438e-04,3.714224902639380577e-04,3.694233600760063550e-04,3.674420963950460217e-04,3.654784765069142485e-04,3.635322812536708674e-04,3.616032949644316778e-04,3.596913053878066590e-04,3.577961036258776417e-04,3.559174840696785209e-04,3.540552443361361600e-04,3.522091852064356118e-04,3.503791105657715998e-04,3.485648273444508618e-04,3.467661454603105514e-04,3.449828777624193606e-04,3.432148399760269366e-04,3.414618506487316729e-04,3.397237310978348324e-04,3.380003053588509737e-04,3.362914001351456758e-04,3.345968447486721560e-04,3.329164710917796219e-04,3.312501135800651137e-04,3.295976091062452007e-04,3.279587969950195614e-04,3.263335189589041101e-04,3.247216190550084643e-04,3.231229436427349297e-04,3.215373413423760172e-04,3.199646629945896228e-04,3.184047616207293162e-04,3.168574923840089238e-04,3.153227125514828657e-04,3.138002814568203449e-04,3.122900604638560967e-04,3.107919129308977482e-04,3.093057041757727127e-04,3.078313014415968367e-04,3.063685738632465866e-04,3.049173924345199740e-04,3.034776299759685486e-04,3.020491611033846282e-04,3.006318621969299968e-04,2.992256113708888872e-04,2.978302884440323984e-04,2.964457749105792791e-04,2.950719539117397944e-04,2.937087102078284203e-04,2.923559301509335456e-04,2.910135016581299810e-04,2.896813141852228892e-04,2.883592587010105055e-04,2.870472276620542116e-04,2.857451149879440891e-04,2.844528160370489488e-04,2.831702275827398859e-04,2.818972477900771141e-04,2.806337761929485327e-04,2.793797136716516245e-04,2.781349624309074615e-04,2.768994259782977130e-04,2.756730091031152222e-04,2.744556178556194779e-04,2.732471595266870073e-04,2.720475426278496961e-04,2.708566768717103569e-04,2.696744731527293652e-04,2.685008435283732574e-04,2.673357012006172652e-04,2.661789604977951758e-04,2.650305368567875699e-04,2.638903468055428026e-04,2.627583079459217268e-04,2.616343389368611170e-04,2.605183594778477728e-04,2.594102902926969561e-04,2.583100531136292566e-04,2.572175706656382394e-04,2.561327666511448642e-04,2.550555657349306529e-04,2.539858935293442393e-04,2.529236765797768542e-04,2.518688423503993748e-04,2.508213192101567098e-04,2.497810364190135562e-04,2.487479241144467039e-04,2.477219132981786295e-04,2.467029358231473380e-04,2.456909243807077351e-04,2.446858124880602493e-04,2.436875344759006576e-04,2.426960254762884595e-04,2.417112214107281344e-04,2.407330589784591071e-04,2.397614756449506013e-04,2.387964096305973411e-04,2.378377998996114389e-04,2.368855861491068375e-04,2.359397087983730005e-04,2.350001089783331594e-04,2.340667285211841934e-04,2.331395099502143445e-04,2.322183964697946488e-04,2.313033319555419436e-04,2.303942609446488676e-04,2.294911286263779022e-04,2.285938808327170389e-04,2.277024640291928199e-04,2.268168253058378762e-04,2.259369123683108789e-04,2.250626735291650791e-04,2.241940576992626467e-04,2.233310143793323943e-04,2.224734936516676892e-04,2.216214461719622213e-04,2.207748231612811332e-04,2.199335763981638818e-04,2.190976582108582606e-04,2.182670214696807857e-04,2.174416195795030667e-04,2.166214064723605292e-04,2.158063366001817824e-04,2.149963649276359471e-04,2.141914469250965638e-04,2.133915385617182021e-04,2.125965962986263707e-04,2.118065770822155213e-04,2.110214383375555002e-04,2.102411379619036828e-04,2.094656343183201336e-04,2.086948862293852786e-04,2.079288529710168081e-04,2.071674942663852162e-04,2.064107702799251821e-04,2.056586416114417125e-04,2.049110692903090628e-04,2.041680147697606243e-04,2.034294399212685555e-04,2.026953070290110170e-04,2.019655787844258448e-04,2.012402182808488990e-04,2.005191890082356804e-04,1.998024548479645590e-04,1.990899800677203705e-04,1.983817293164568871e-04,1.976776676194367014e-04,1.969777603733470852e-04,1.962819733414907127e-04,1.955902726490497566e-04,1.949026247784221117e-04,1.942189965646285517e-04,1.935393551907892747e-04,1.928636681836690798e-04,1.921919034092898712e-04,1.915240290686087850e-04,1.908600136932616384e-04,1.901998261413699403e-04,1.895434355934107044e-04,1.888908115481476827e-04,1.882419238186234763e-04,1.875967425282107088e-04,1.869552381067221796e-04,1.863173812865780198e-04,1.856831430990297952e-04,1.850524948704400125e-04,1.844254082186159440e-04,1.838018550491977434e-04,1.831818075520988203e-04,1.825652381979983379e-04,1.819521197348848035e-04,1.813424251846496678e-04,1.807361278397303099e-04,1.801332012598016758e-04,1.795336192685154585e-04,1.789373559502861711e-04,1.783443856471235141e-04,1.777546829555101443e-04,1.771682227233235438e-04,1.765849800468027744e-04,1.760049302675574078e-04,1.754280489696194987e-04,1.748543119765370282e-04,1.742836953485088459e-04,1.737161753795595095e-04,1.731517285947542137e-04,1.725903317474528314e-04,1.720319618166022541e-04,1.714765960040668421e-04,1.709242117319959822e-04,1.703747866402281817e-04,1.698282985837315658e-04,1.692847256300795836e-04,1.687440460569617612e-04,1.682062383497287972e-04,1.676712811989714306e-04,1.671391534981327837e-04,1.666098343411531225e-04,1.660833030201472793e-04,1.655595390231134618e-04,1.650385220316733968e-04,1.645202319188435083e-04,1.640046487468356951e-04,1.634917527648886010e-04,1.629815244071279687e-04,1.624739442904554276e-04,1.619689932124665813e-04,1.614666521493962007e-04,1.609669022540914434e-04,1.604697248540121787e-04,1.599751014492578475e-04,1.594830137106206694e-04,1.589934434776648698e-04,1.585063727568312238e-04,1.580217837195667526e-04,1.575396587004792225e-04,1.570599801955158744e-04,1.565827308601662232e-04,1.561078935076885203e-04,1.556354511073591461e-04,1.551653867827453134e-04,1.546976838100001599e-04,1.542323256161799846e-04,1.537692957775834129e-04,1.533085780181122726e-04,1.528501562076534494e-04,1.523940143604818841e-04,1.519401366336839529e-04,1.514885073256014747e-04,1.510391108742953966e-04,1.505919318560292931e-04,1.501469549837722729e-04,1.497041651057211839e-04,1.492635472038413859e-04,1.488250863924263064e-04,1.483887679166750486e-04,1.479545771512883498e-04,1.475224995990821308e-04,1.470925208896183922e-04,1.466646267778538653e-04,1.462388031428049249e-04,1.458150359862300132e-04,1.453933114313280006e-04,1.449736157214532434e-04,1.445559352188463087e-04,1.441402564033807988e-04,1.437265658713256808e-04,1.433148503341228480e-04,1.429050966171800240e-04,1.424972916586783839e-04,1.420914225083951378e-04,1.416874763265402908e-04,1.412854403826080657e-04,1.408853020542421772e-04,1.404870488261149297e-04,1.400906682888203552e-04,1.396961481377805513e-04,1.393034761721654636e-04,1.389126402938257597e-04,1.385236285062386053e-04,1.381364289134663962e-04,1.377510297191278236e-04,1.373674192253815970e-04,1.369855858319221479e-04,1.366055180349875576e-04,1.362272044263795738e-04,1.358506336924948763e-04,1.354757946133684310e-04,1.351026760617278760e-04,1.347312670020594540e-04,1.343615564896848418e-04,1.339935336698490917e-04,1.336271877768192265e-04,1.332625081329936480e-04,1.328994841480218739e-04,1.325381053179348987e-04,1.321783612242855032e-04,1.318202415332988631e-04,1.314637359950329156e-04,1.311088344425488368e-04,1.307555267910908694e-04,1.304038030372759902e-04,1.300536532582928203e-04,1.297050676111098319e-04,1.293580363316929342e-04,1.290125497342319493e-04,1.286685982103759514e-04,1.283261722284777403e-04,1.279852623328464199e-04,1.276458591430094090e-04,1.273079533529820678e-04,1.269715357305462706e-04,1.266365971165369730e-04,1.263031284241368578e-04,1.259711206381792733e-04,1.256405648144589529e-04,1.253114520790502950e-04,1.249837736276339655e-04,1.246575207248305198e-04,1.243326847035418586e-04,1.240092569643001645e-04,1.236872289746238313e-04,1.233665922683810649e-04,1.230473384451601516e-04,1.227294591696472339e-04,1.224129461710107554e-04,1.220977912422927349e-04,1.217839862398071026e-04,1.214715230825443775e-04,1.211603937515832443e-04,1.208505902895083911e-04,1.205421047998350551e-04,1.202349294464397355e-04,1.199290564529971806e-04,1.196244781024236368e-04,1.193211867363262767e-04,1.190191747544584559e-04,1.187184346141811756e-04,1.184189588299302111e-04,1.181207399726892437e-04,1.178237706694685899e-04,1.175280436027897852e-04,1.172335515101753856e-04,1.169402871836448137e-04,1.166482434692152191e-04,1.163574132664079493e-04,1.160677895277603748e-04,1.157793652583427406e-04,1.154921335152805760e-04,1.152060874072818192e-04,1.149212200941692960e-04,1.146375247864181315e-04,1.143549947446980135e-04,1.140736232794204428e-04,1.137934037502908227e-04,1.135143295658650744e-04,1.132363941831113072e-04,1.129595911069758402e-04,1.126839138899540067e-04,1.124093561316653097e-04,1.121359114784332398e-04,1.118635736228694016e-04,1.115923363034619647e-04,1.113221933041686542e-04,1.110531384540136709e-04,1.107851656266891391e-04,1.105182687401605381e-04,1.102524417562762406e-04,1.099876786803812516e-04,1.097239735609347838e-04,1.094613204891319383e-04,1.091997135985292350e-04,1.089391470646740051e-04,1.086796151047376735e-04,1.084211119771527268e-04,1.081636319812535581e-04,1.079071694569207944e-04,1.076517187842294596e-04,1.073972743831006876e-04,1.071438307129569603e-04,1.068913822723808137e-04,1.066399235987772177e-04,1.063894492680391942e-04,1.061399538942169328e-04,1.058914321291901578e-04,1.056438786623441011e-04,1.053972882202481719e-04,1.051516555663387190e-04,1.049069755006041513e-04,1.046632428592736500e-04,1.044204525145091061e-04,1.041785993740998765e-04,1.039376783811607257e-04,1.036976845138328163e-04,1.034586127849875724e-04,1.032204582419337421e-04,1.029832159661269396e-04,1.027468810728826435e-04,1.025114487110915254e-04,1.022769140629379241e-04,1.020432723436210558e-04,1.018105188010787058e-04,1.015786487157141444e-04,1.013476574001252669e-04,1.011175401988366593e-04,1.008882924880341998e-04,1.006599096753023836e-04,1.004323871993639513e-04,1.002057205298223779e-04,9.997990516690667847e-05,9.975493664121878900e-05,9.953081051348333262e-05,9.930752237429989291e-05,9.908506784389769964e-05,9.886344257189253707e-05,9.864264223704622726e-05,9.842266254702829534e-05,9.820349923817997930e-05,9.798514807528044897e-05,9.776760485131542368e-05,9.755086538724782284e-05,9.733492553179077470e-05,9.711978116118269856e-05,9.690542817896460968e-05,9.669186251575942991e-05,9.647908012905362938e-05,9.626707700298068422e-05,9.605584914810674335e-05,9.584539260121831457e-05,9.563570342511198356e-05,9.542677770838598958e-05,9.521861156523398308e-05,9.501120113524053165e-05,9.480454258317869945e-05,9.459863209880942916e-05,9.439346589668284838e-05,9.418904021594147339e-05,9.398535132012525602e-05,9.378239549697829755e-05,9.358016905825763607e-05,9.337866833954359242e-05,9.317788970005204060e-05,9.297782952244825025e-05,9.277848421266265359e-05,9.257985019970815734e-05,9.238192393549929783e-05,9.218470189467291396e-05,9.198818057441058194e-05,9.179235649426266289e-05,9.159722619597393599e-05,9.140278624331091219e-05,9.120903322189065224e-05,9.101596373901118392e-05,9.082357442348350490e-05,9.063186192546507640e-05,9.044082291629484830e-05,9.025045408832984271e-05,9.006075215478310646e-05,8.987171384956324917e-05,8.968333592711540429e-05,8.949561516226365394e-05,8.930854835005479534e-05,8.912213230560358450e-05,8.893636386393945713e-05,8.875123987985442868e-05,8.856675722775256634e-05,8.838291280150070803e-05,8.819970351428055007e-05,8.801712629844204950e-05,8.783517810535812747e-05,8.765385590528075490e-05,8.747315668719819021e-05,8.729307745869358578e-05,8.711361524580486836e-05,8.693476709288578503e-05,8.675653006246822308e-05,8.657890123512576315e-05,8.640187770933842500e-05,8.622545660135867371e-05,8.604963504507844225e-05,8.587441019189752292e-05,8.569977921059301581e-05,8.552573928718992932e-05,8.535228762483294612e-05,8.517942144365928689e-05,8.500713798067269895e-05,8.483543448961858324e-05,8.466430824086011069e-05,8.449375652125555830e-05,8.432377663403666163e-05,8.415436589868787538e-05,8.398552165082700269e-05,8.381724124208651567e-05,8.364952203999614986e-05,8.348236142786644740e-05,8.331575680467320809e-05,8.314970558494307908e-05,8.298420519864007944e-05,8.281925309105307362e-05,8.265484672268419344e-05,8.249098356913838500e-05,8.232766112101361970e-05,8.216487688379233844e-05,8.200262837773360063e-05,8.184091313776626318e-05,8.167972871338309462e-05,8.151907266853571587e-05,8.135894258153044908e-05,8.119933604492510161e-05,8.104025066542660377e-05,8.088168406378947329e-05,8.072363387471518780e-05,8.056609774675239758e-05,8.040907334219796502e-05,8.025255833699887140e-05,8.009655042065489620e-05,7.994104729612219089e-05,7.978604667971755742e-05,7.963154630102367538e-05,7.947754390279492551e-05,7.932403724086424318e-05,7.917102408405052750e-05,7.901850221406694495e-05,7.886646942543001904e-05,7.871492352536934331e-05,7.856386233373821603e-05,7.841328368292485758e-05,7.826318541776445452e-05,7.811356539545198977e-05,7.796442148545561484e-05,7.781575156943091654e-05,7.766755354113579358e-05,7.751982530634601073e-05,7.737256478277160687e-05,7.722576989997379090e-05,7.707943859928261009e-05,7.693356883371532326e-05,7.678815856789543795e-05,7.664320577797230328e-05,7.649870845154152954e-05,7.635466458756585495e-05,7.621107219629689338e-05,7.606792929919732930e-05,7.592523392886379031e-05,7.578298412895042452e-05,7.564117795409295208e-05,7.549981346983355719e-05,7.535888875254613225e-05,7.521840188936224048e-05,7.507835097809775608e-05,7.493873412717996514e-05,7.479954945557533072e-05,7.466079509271777287e-05,7.452246917843761270e-05,7.438456986289097731e-05,7.424709530648993644e-05,7.411004367983299167e-05,7.397341316363627013e-05,7.383720194866513851e-05,7.370140823566661658e-05,7.356603023530199406e-05,7.343106616808015214e-05,7.329651426429154915e-05,7.316237276394240948e-05,7.302863991668972566e-05,7.289531398177659925e-05,7.276239322796817805e-05,7.262987593348810831e-05,7.249776038595536637e-05,7.236604488232178153e-05,7.223472772880980286e-05,7.210380724085106556e-05,7.197328174302510646e-05,7.184314956899887908e-05,7.171340906146640422e-05,7.158405857208922018e-05,7.145509646143714463e-05,7.132652109892937537e-05,7.119833086277626861e-05,7.107052413992156461e-05,7.094309932598478943e-05,7.081605482520445622e-05,7.068938905038138867e-05,7.056310042282277605e-05,7.043718737228649954e-05,7.031164833692579719e-05,7.018648176323463370e-05,7.006168610599317862e-05,6.993725982821390793e-05,6.981320140108812579e-05,6.968950930393275729e-05,6.956618202413760203e-05,6.944321805711311624e-05,6.932061590623842526e-05,6.919837408280983754e-05,6.907649110598962957e-05,6.895496550275542725e-05,6.883379580784980401e-05,6.871298056373028554e-05,6.859251832051980178e-05,6.847240763595742344e-05,6.835264707534960003e-05,6.823323521152158762e-05,6.811417062476944574e-05,6.799545190281219701e-05,6.787707764074458301e-05,6.775904644098987436e-05,6.764135691325330428e-05,6.752400767447575957e-05,6.740699734878775624e-05,6.729032456746383525e-05,6.717398796887726997e-05,6.705798619845512601e-05,6.694231790863367339e-05,6.682698175881411043e-05,6.671197641531850450e-05,6.659730055134636972e-05,6.648295284693121754e-05,6.636893198889760881e-05,6.625523667081858526e-05,6.614186559297320948e-05,6.602881746230464689e-05,6.591609099237836979e-05,6.580368490334082216e-05,6.569159792187826059e-05,6.557982878117600187e-05,6.546837622087788738e-05,6.535723898704614047e-05,6.524641583212137299e-05,6.513590551488310676e-05,6.502570680041028152e-05,6.491581846004242692e-05,6.480623927134072611e-05,6.469696801804968923e-05,6.458800349005886746e-05,6.447934448336501442e-05,6.437098980003447789e-05,6.426293824816576769e-05,6.415518864185254381e-05,6.404773980114672634e-05,6.394059055202201214e-05,6.383373972633763535e-05,6.372718616180218212e-05,6.362092870193802885e-05,6.351496619604567184e-05,6.340929749916858569e-05,6.330392147205824414e-05,6.319883698113926303e-05,6.309404289847500395e-05,6.298953810173335414e-05,6.288532147415262829e-05,6.278139190450790410e-05,6.267774828707743911e-05,6.257438952160949410e-05,6.247131451328918363e-05,6.236852217270574665e-05,6.226601141581997981e-05,6.216378116393184692e-05,6.206183034364844077e-05,6.196015788685205335e-05,6.185876273066859851e-05,6.175764381743606164e-05,6.165680009467339661e-05,6.155623051504953121e-05,6.145593403635256217e-05,6.135590962145922136e-05,6.125615623830458589e-05,6.115667285985185598e-05,6.105745846406255293e-05,6.095851203386677133e-05,6.085983255713369556e-05,6.076141902664233309e-05,6.066327044005236297e-05,6.056538579987539775e-05,6.046776411344618432e-05,6.037040439289417072e-05,6.027330565511526266e-05,6.017646692174370883e-05,6.007988721912421655e-05,5.998356557828430464e-05,5.988750103490677142e-05,5.979169262930237287e-05,5.969613940638273785e-05,5.960084041563345282e-05,5.950579471108726848e-05,5.941100135129754358e-05,5.931645939931195984e-05,5.922216792264618253e-05,5.912812599325798201e-05,5.903433268752132125e-05,5.894078708620070089e-05,5.884748827442572118e-05,5.875443534166572516e-05,5.866162738170470619e-05,5.856906349261629675e-05,5.847674277673904863e-05,5.838466434065173345e-05,5.829282729514895489e-05,5.820123075521679477e-05,5.810987384000875058e-05,5.801875567282174074e-05,5.792787538107230629e-05,5.783723209627302956e-05,5.774682495400897987e-05,5.765665309391441670e-05,5.756671565964970977e-05,5.747701179887822518e-05,5.738754066324354365e-05,5.729830140834678032e-05,5.720929319372395884e-05,5.712051518282375132e-05,5.703196654298511669e-05,5.694364644541528457e-05,5.685555406516780023e-05,5.676768858112071179e-05,5.668004917595495388e-05,5.659263503613278564e-05,5.650544535187652001e-05,5.641847931714721236e-05,5.633173612962367441e-05,5.624521499068144750e-05,5.615891510537206720e-05,5.607283568240238895e-05,5.598697593411405599e-05,5.590133507646313663e-05,5.581591232899985652e-05,5.573070691484845955e-05,5.564571806068729920e-05,5.556094499672886890e-05,5.547638695670020504e-05,5.539204317782321554e-05,5.530791290079525223e-05,5.522399536976975790e-05,5.514028983233708266e-05,5.505679553950534779e-05,5.497351174568156708e-05,5.489043770865278168e-05,5.480757268956732375e-05,5.472491595291624272e-05,5.464246676651489420e-05,5.456022440148452883e-05,5.447818813223406418e-05,5.439635723644204628e-05,5.431473099503860449e-05,5.423330869218756213e-05,5.415208961526875721e-05,5.407107305486034282e-05,5.399025830472124342e-05,5.390964466177380757e-05,5.382923142608645394e-05,5.374901790085651380e-05,5.366900339239311416e-05};
	// Cutoffs: Setting the cutoff at cutoffs[0] gives an average degree of 1, 4 gives 2 and so on.
	vector<int> cutoffs = {2, 4, 6, 8, 11, 13, 16, 19, 22, 25, 28, 32, 36, 40, 44, 48, 52, 57, 62, 67, 72, 77, 83, 89, 94, 100, 107, 113, 120, 126, 133, 141, 148, 155, 163, 171, 179, 187, 195, 204, 213, 221, 230, 240, 249, 259, 268, 278, 289, 299, 309, 320, 331, 342, 353, 364, 376, 388, 400, 412, 424, 436, 449, 462, 475, 488, 501, 515, 528, 542, 556, 570, 585, 599, 614, 629, 644, 659, 675, 690, 706, 722, 738, 754, 771, 788, 804, 821, 839, 856, 874, 891, 909, 927, 946, 964, 983, 1001, 1020, 1040, 1059, 1078, 1098, 1118, 1138, 1158, 1179, 1199, 1220, 1241, 1262, 1283, 1305, 1326, 1348, 1370, 1392, 1414, 1437, 1460, 1483, 1506, 1529, 1552, 1576, 1599, 1623, 1648, 1672, 1696, 1721, 1746, 1771, 1796, 1821, 1847, 1872, 1898, 1924, 1951, 1977, 2004, 2030, 2057, 2084, 2112, 2139, 2167, 2195, 2223, 2251, 2279, 2308, 2336, 2365, 2394, 2423, 2453, 2482, 2512, 2542, 2572, 2603, 2633, 2664, 2694, 2725, 2757, 2788, 2820, 2851, 2883, 2915, 2947, 2980, 3012, 3045, 3078, 3111, 3145, 3178, 3212, 3246, 3280, 3314, 3348, 3383, 3417, 3452, 3487, 3523, 3558, 3594, 3629, 3665, 3701, 3738, 3774, 3811, 3848, 3885, 3922, 3959, 3997, 4035, 4073, 4111, 4149, 4187, 4226, 4265, 4304, 4343, 4382, 4422, 4461, 4501, 4541, 4581, 4622, 4662, 4703, 4744, 4785, 4826, 4868, 4909, 4951, 4993, 5035, 5078, 5120, 5163, 5206, 5249, 5292, 5335, 5379, 5422, 5466, 5510, 5555, 5599, 5644, 5689, 5734, 5779, 5824, 5870, 5915, 5961, 6007, 6053, 6100, 6146, 6193, 6240, 6287, 6334, 6382, 6429, 6477, 6525, 6573, 6622, 6670, 6719, 6768, 6817, 6866, 6916, 6965, 7015, 7065, 7115, 7165, 7216, 7266, 7317, 7368, 7419, 7471, 7522, 7574, 7626, 7678, 7730, 7782, 7835, 7888, 7941, 7994, 8047, 8101, 8154, 8208, 8262, 8316, 8371, 8425, 8480, 8535, 8590, 8645, 8700, 8756, 8812, 8868, 8924, 8980, 9037, 9093, 9150, 9207, 9264, 9322, 9379, 9437, 9495, 9553, 9611, 9669, 9728, 9787, 9846, 9905, 9964, 10024, 10083, 10143, 10203, 10263, 10324, 10384, 10445, 10506, 10567, 10628, 10690, 10751, 10813, 10875, 10937, 11000, 11062, 11125, 11188, 11251, 11314, 11377, 11441, 11504, 11568, 11632, 11697, 11761, 11826, 11890, 11955, 12021, 12086, 12151, 12217, 12283, 12349, 12415, 12482, 12548, 12615, 12682, 12749, 12816, 12884, 12951, 13019, 13087, 13155, 13223, 13292, 13361, 13429, 13499, 13568, 13637, 13707, 13776, 13846, 13916, 13987, 14057, 14128, 14199, 14270, 14341, 14412, 14484, 14555, 14627, 14699, 14771, 14844, 14916, 14989, 15062, 15135, 15208, 15282, 15356, 15429, 15503, 15578, 15652, 15726, 15801, 15876, 15951, 16026, 16102, 16177, 16253, 16329, 16405, 16481, 16558, 16634, 16711, 16788, 16865, 16943, 17020, 17098, 17176, 17254, 17332, 17411, 17489, 17568, 17647, 17726, 17805, 17885, 17964, 18044, 18124, 18204, 18285, 18365, 18446, 18527, 18608, 18689, 18771, 18852, 18934, 19016, 19098, 19180, 19263, 19346, 19428, 19511, 19595, 19678, 19761, 19845, 19929, 20013, 20097, 20182, 20266, 20351, 20436, 20521, 20607, 20692, 20778, 20864, 20950, 21036, 21122, 21209, 21295, 21382, 21469, 21557, 21644, 21732, 21820, 21908, 21996, 22084, 22172, 22261, 22350, 22439, 22528, 22618, 22707, 22797, 22887, 22977, 23067, 23158, 23248, 23339, 23430, 23521, 23612, 23704, 23796, 23888, 23980, 24072, 24164, 24257, 24349, 24442, 24535, 24629, 24722, 24816, 24910, 25004, 25098, 25192, 25287, 25381, 25476, 25571, 25666, 25762, 25857, 25953, 26049, 26145, 26241, 26338, 26435, 26531, 26628, 26725, 26823, 26920, 27018, 27116, 27214, 27312, 27411, 27509, 27608};
	int cutoff = cutoffs[avg_deg_int-1];
	cout << "Cutoff is ... " << cutoff << endl;
	mat p_vec(1, cutoff+1, fill::zeros);
	// Then add all p_inf_full[0:cutoff] to p_vec:
	for (int i = 0; i <= cutoff; i++) {
		p_vec[i] = p_list_full[i];
		// DEBUG:
		//cout << "Adding " << i << ", " <<  p_vec[i] << endl;
	}
	p_vec = p_vec/accu(p_vec);
	// DEBUG:
	cout << "Normalization of degree distribution: " << accu(p_vec) << endl;
	float px_sum = 0.0;
	for (int i = 0; i <= cutoff; i++) {
		px_sum = px_sum + p_vec[i] * i;
	}
	cout << "Mean of degree distribution: " << px_sum << endl;
	discrete_distribution<> d(p_vec.begin(), p_vec.end());
	for (int i = 0; i < num_nodes; i++)
	{
		degrees[i] = d(gen);
		// DEBUG:
		//cout << "Adding node with degree " << degrees[i] << endl;
	}
	auto [edgelist, neighbordict] = configuration_model(degrees);
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
}

//vector<tuple<int, int>>, map<int, vector<int> > gen_ER(int num_nodes, int num_edges, bool verbose=false)
auto gen_ER(int num_nodes, int num_edges, bool verbose=false)
{
	// Initiate the vector which is to hold the list of edges in the network
	vector<vector<int>> edgelist;
	// Next, initiate the neighbordict, which is supposed to work like this (pseudo-code):
	// neighbordict[1] = [2,43,6]
	map<int, vector<int> > neighbordict;
	for(int i=0; i < num_edges; i++){
		int src = (rand() % num_nodes);
		int dst = (rand() % num_nodes);
		int edge_exists = 0;
		if (neighbordict[src].size() > 0) {
			edge_exists = count(neighbordict[src].begin(), neighbordict[src].end(), dst);
		}
		while ((src == dst) || edge_exists) {
			//cout << "i = " << i << "." << " src: " << src << " dst: " << dst << " edge_exists: " << edge_exists << endl;
			dst = (rand() % num_nodes);
			edge_exists = count(neighbordict[src].begin(), neighbordict[src].end(), dst);
		};
		//vector<int> new_edge_forward (src,dst);
		//vector<int> new_edge_backward (dst, src);
		vector<int> new_edge_forward;
		vector<int> new_edge_backward;
		//new_edge_forward[0] = src;
		//new_edge_forward[1] = dst;
		//new_edge_backward[0] = dst;
		//new_edge_backward[1] = src;
		new_edge_forward.push_back(src);
		new_edge_forward.push_back(dst);
		new_edge_backward.push_back(dst);
		new_edge_backward.push_back(src);
		if(verbose) {
			cout << "(src,dst)" << endl;
			cout << "(" << new_edge_forward[0] << "," << new_edge_forward[1] << ")" << endl;
			cout << "(dst,src)" << endl;
			cout << "(" << new_edge_backward[0] << "," << new_edge_backward[1] << ")" << endl;
		};
		// Add edges to the edgelist (which is in fact a vector)
		edgelist.emplace_back(new_edge_forward);
		edgelist.emplace_back(new_edge_backward);
		// Add edges to the edgedict as well - it's double book-keeping, but it
		// simplifies things to be able to look up edges by the user ID
		neighbordict[new_edge_forward[0] ].emplace_back(new_edge_forward[1]);
		neighbordict[new_edge_backward[0] ].emplace_back(new_edge_backward[1]);
	};
	//struct retVals {        // Declare a local structure
	//	vector<vector<int>> el; // For returning edgelist
	//	map<int, vector<int> > nd; // For returning neighbordict
	//};
	//return retVals {edgelist, neighbordict}; // Return the local structure
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
	//return edgelist, neighbordict;
	//return neighbordict;
}

auto enlarge_ER_network(vector<vector<int>> edgelist, map<int, vector<int> > neighbordict, int num_nodes, int num_new_edges) {
	for(int i=0; i < num_new_edges; i++){
		int src = (rand() % num_nodes);
		int dst = (rand() % num_nodes);
		int edge_exists = 0;
		if (neighbordict[src].size() > 0) {
			edge_exists = count(neighbordict[src].begin(), neighbordict[src].end(), dst);
		}
		while ((src == dst) || edge_exists) {
			//cout << "i = " << i << "." << " src: " << src << " dst: " << dst << " edge_exists: " << edge_exists << endl;
			dst = (rand() % num_nodes);
			edge_exists = count(neighbordict[src].begin(), neighbordict[src].end(), dst);
		};
		//vector<int> new_edge_forward (src,dst);
		//vector<int> new_edge_backward (dst, src);
		vector<int> new_edge_forward;
		vector<int> new_edge_backward;
		//new_edge_forward[0] = src;
		//new_edge_forward[1] = dst;
		//new_edge_backward[0] = dst;
		//new_edge_backward[1] = src;
		new_edge_forward.push_back(src);
		new_edge_forward.push_back(dst);
		new_edge_backward.push_back(dst);
		new_edge_backward.push_back(src);
		// Add edges to the edgelist (which is in fact a vector)
		edgelist.emplace_back(new_edge_forward);
		edgelist.emplace_back(new_edge_backward);
		// Add edges to the edgedict as well - it's double book-keeping, but it
		// simplifies things to be able to look up edges by the user ID
		neighbordict[new_edge_forward[0] ].emplace_back(new_edge_forward[1]);
		neighbordict[new_edge_backward[0] ].emplace_back(new_edge_backward[1]);
	}
	cout << "Connectivity increased!" << endl;
	int degsum = 0;
	for (int i = 0; i < num_nodes; i++) {
		degsum += neighbordict[i].size();
	};
	cout << "Average node degree (measured): " << float(degsum)/(float(num_nodes)) << endl;
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
}

auto gen_clusternet(int num_nodes, int num_edges, int ER_edges) // Note: ER_edges must be less than or equal to num_edges
{
	// Initiate the vector which is to hold the list of edges in the network and the
	// neighbordict, which is supposed to work like this (pseudo-code):
	// neighbordict[1] = [2,43,6]
	// We populate it with the Erdos-Renyi nodes, which we will later "clusterize":
	auto [edgelist, neighbordict] = gen_ER(num_nodes, ER_edges);
	// Now we will add extra edges to form clusters.
	// The number of extra edges is of course num_edges-ER_edges.
	// The procedure is as follows:
	// Pick a random node. If this node has at least two neighbors, then pick
	// two of the node's neighbors and connect them (if they are not already
	// connected). Continue until there are num_edges edges in the network.
	int edges_added = 0;
	int attempts = 0;
	while (edges_added < num_edges-ER_edges) {
		attempts++;
		// DEBUG:
		if (((float)edges_added/(float)attempts < 0.2) && (edges_added > 100)) {
			cout << "Warning: success rate low! Attempts: " << attempts << " edges_added; " << edges_added << endl;
		}
		int initial_node = (rand() % num_nodes);
		if (neighbordict[initial_node].size() > 1) { // Has at least 2 neighbors, which we can connect.
			// Pick two random (distinct!) neighbors from initial_node's neighbors:
			int src = neighbordict[initial_node][(rand() % neighbordict[initial_node].size())];
			int dst = neighbordict[initial_node][(rand() % neighbordict[initial_node].size())];
			int retries = 0;
			while (src == dst) {
				retries++;
				if (neighbordict[initial_node].size() == 2) { // Special case for node with just two neighbors. Not strictly necessary, but speeds things up!
					if (neighbordict[initial_node][0] == src) {
						dst = neighbordict[initial_node][1];
					}
					else {
						dst = neighbordict[initial_node][0];
					}
				}
				else {
					dst = neighbordict[initial_node][(rand() % neighbordict[initial_node].size())];
				}
				if (retries > 10) {
					cout << "Warning: potentially stuck in retry loop with src = " << src << "and initial_node = " << initial_node << " with neighbors: " << endl;
					print_intvec(neighbordict[initial_node]);
				}
			};
			vector<int> new_edge_forward;
			vector<int> new_edge_backward;
			new_edge_forward.push_back(src);
			new_edge_forward.push_back(dst);
			new_edge_backward.push_back(dst);
			new_edge_backward.push_back(src);
			// We must then check that neither (src,dst) nor (dst,src) are already in the edgelist,
			// but since we always add links to the list in both directions, we can get by with checking just one of them
			//if ((count(edgelist.begin(), edgelist.end(), new_edge_forward) == 0) && (count(edgelist.begin(), edgelist.end(), new_edge_backward) == 0)) {
			if (count(neighbordict[src].begin(), neighbordict[src].end(), dst) == 0) {
				// Neither (src,dst) or (dst,src) were found in the edgelist, so we can add the link.
				// Add edges to the edgelist (which is in fact a vector)
				edgelist.emplace_back(new_edge_forward);
				edgelist.emplace_back(new_edge_backward);
				// Add edges to the edgedict as well - it's double book-keeping, but it
				// simplifies things to be able to look up edges by the user ID
				neighbordict[new_edge_forward[0] ].emplace_back(new_edge_forward[1]);
				neighbordict[new_edge_backward[0] ].emplace_back(new_edge_backward[1]);
				edges_added++;
				if ((edges_added == 10000) || (edges_added == 50000))
				{
					cout << "Target: " <<  num_edges-ER_edges << ". Edges added:" << edges_added << " out of " << attempts << " attempts." << endl;
				}
			}
		}

	}
	//struct retVals {        // Declare a local structure
	//	vector<vector<int>> el; // For returning edgelist
	//	map<int, vector<int> > nd; // For returning neighbordict
	//};
	//return retVals {edgelist, neighbordict}; // Return the local structure
	return Edgelist_and_neighbordict {edgelist, neighbordict}; // Return structure
}


auto init_arrs(map<int, vector<int> > neighbordict, int n_tsteps, int n_users, mat var_alpha, mat var_pinf, mat var_fraction, string inf_dist, float p_inf0, float initrec, mat a_vec, string vacc_scheme) {
	cout << "Number of timesteps: " << n_tsteps << endl;
	umat S_t(1,n_tsteps,fill::ones);
	umat E_t(1,n_tsteps,fill::zeros);
	umat I_t(1,n_tsteps,fill::zeros);
	umat R_t(1,n_tsteps,fill::zeros);
	umat S(1,n_users,fill::ones);
	umat E(3,n_users,fill::zeros);
	umat I(1,n_users,fill::zeros);
	umat R(1,n_users,fill::zeros);
	umat var1_EI_t(1,n_tsteps,fill::zeros);
	umat var2_EI_t(1,n_tsteps,fill::zeros);
	umat var1_R_t(1,n_tsteps,fill::zeros);
	umat var2_R_t(1,n_tsteps,fill::zeros);
	map<int, vector<int> > R0tree;
	map<int, vector<int> > R0times;
	// Move some from S to I, to have some initially infected:
	umat S_to_I; // A logical matrix can be contained in a umat.
	S_to_I = (mat(1,n_users,fill::randu) < p_inf0) % S; // Note the multiplication by S
	S = S - S_to_I;
	I = I + S_to_I;
	// Move some from S to R, the initially immune:
	cout << endl;
	cout << "VVVV- Vaccination -VVVV" << endl;
	umat S_to_R(1,n_users,fill::zeros);
	if (vacc_scheme == "vacc_random") {
		cout << "Vaccinating following scheme: " << vacc_scheme << endl;
		S_to_R = (mat(1,n_users,fill::randu) < initrec) % S;
	}
	else if (vacc_scheme == "vacc_active") {
		cout << "Vaccinating following scheme: " << vacc_scheme << endl;
		int n_vacc = int(n_users * initrec); // Number to vaccinate
		umat s_idx = sort_index(a_vec, "descend");
		for (int i=0; i < n_vacc; i++) {
			S_to_R(s_idx(i)) = 1 * S(s_idx(i));
		}
	}
	else if (vacc_scheme == "vacc_diverse") {
		cout << "Vaccinating following scheme: " << vacc_scheme << endl;
		int n_vacc = int(n_users * initrec); // Number to vaccinate
		// First we must generate a vector of the diversity (number of distinct connections) of each person:
		umat diversities(1,n_users,fill::zeros);
		for (int i = 0; i < n_users; i++) {
			diversities(i) += int(neighbordict[i].size());
		}
		// Then we get the sorting index, ranking users from most to least "diverse":
		umat s_idx = sort_index(diversities, "descend");
		// And then we vaccinate the first n_vacc of these:
		for (int i=0; i < n_vacc; i++) {
			S_to_R(s_idx(i)) = 1 * S(s_idx(i));
		}
	}
	cout << "Total number initially vaccinated: " << accu(S_to_R) << endl;
	S = S - S_to_R;
	R = R + S_to_R;
	S_t(0) = accu(S);
	E_t(0) = accu(E);
	I_t(0) = accu(I);
	R_t(0) = accu(R);
	// Now we need to assign people a variant based on the var_fraction matrix
	// For now hardcoded to two variants
	umat vars(1,n_users,fill::zeros);
	umat to_var1 = (mat(1,n_users,fill::randu) < var_fraction[0]) % (1-S); // Note the multiplication by 1-S
	umat to_var2 = (1-S) % (1-to_var1);
	vars = vars + to_var1;
	vars = vars + 2*to_var2;
	// Update the t=0 values of the arrays keeping track of the total number of I+E and R indiviuals with each variant:
	int v1_EI = accu( (vars==1) % (I + E.row(0) + E.row(1) + E.row(2) ));
	int v2_EI = accu( (vars==2) % (I + E.row(0) + E.row(1) + E.row(2) ));
	int v1_R = accu( (vars==1) % R);
	int v2_R = accu( (vars==2) % R);
	var1_EI_t(0) = v1_EI;
	var2_EI_t(0) = v2_EI;
	var1_R_t(0) = v1_R;
	var2_R_t(0) = v2_R;
	// DEBUG sanity check:
	cout << "Number of var1: " << accu(to_var1) << endl;
	cout << "Number of var2: " << accu(to_var2) << endl;

	mat p_infvec = generate_infectivities(n_users, vars, var_alpha, var_pinf, inf_dist, true);
	map<int, InfectionTree > infectree;
	for (int i=0; i < n_users; i++) {
		R0tree[i] = {};
		R0times[i] = {};
		if (I[i]) {
			infectree[i].t_infected = 0;
			infectree[i].t_symptom = 0;
		}
		else {
			infectree[i].t_infected = -1;
			infectree[i].t_symptom = -1;
		}
		infectree[i].infected_by = -1;
		infectree[i].users_infected = {};

	}
	struct retVals {        // Declare a local structure
		umat S_t; // For returning S_t
		umat E_t; // For returning S_t
		umat I_t; // For returning I_t
		umat R_t; // For returning R_t
		umat S; // For returning S
		umat E; // For returning E
		umat I; // For returning I
		umat R; // For returning R
		umat vars; // For returning vars
		mat p_infvec; // For returning the list of infectivities
		map<int, InfectionTree > infectree;
		map<int, vector<int> > R0tree;
		map<int, vector<int> > R0times;
		umat var1_EI_t;
		umat var2_EI_t;
		umat var1_R_t;
		umat var2_R_t;
	};
	return retVals {S_t, E_t, I_t, R_t, S, E, I, R, vars, p_infvec, infectree, R0tree, R0times, var1_EI_t, var2_EI_t, var1_R_t, var2_R_t}; // Return the local structure
}

vector<vector<int>> pick_edges_stochastic(vector<vector<int>> edgelist, map<int, vector<int> >  neighbordict, int num_nodes, float p_own, float p_other, mat a_vec){
	// Really stupid mat-to-list routine:
	vector<float> a_list;
	int a;
	for (int i = 0; i < edgelist.size(); i++) {
		//float a = a_vec(edgelist[i][0])*a_vec(edgelist[i][1]);
		float a = pow(a_vec(edgelist[i][0])*a_vec(edgelist[i][1]), 1.0);
		a_list.emplace_back(a); // List of products of activities (or other function of them). i.e. an effective "link activity"
	}
	vector<vector<int>> picked_edges;
	int num_edges_to_pick = int(accu(a_vec));
	random_device rd;
	mt19937 gen(rd());
	discrete_distribution<> d(a_list.begin(), a_list.end());
	discrete_distribution<> activity_discrete_dist(a_vec.begin(), a_vec.end());
	//discrete_distribution<> d(a_vec.begin(), a_vec.end());

	while (picked_edges.size() < num_edges_to_pick) {
		float r = randu();
		if (r < p_own) {
			int edge_idx = d(gen);
			//cout << "edge_idx: " << edge_idx << endl;
			vector<int> sel_edge;
			sel_edge.push_back(edgelist[edge_idx][0]);
			sel_edge.push_back(edgelist[edge_idx][1]);
			//cout << "Adding edge " << sel_edge[0] << "<->" << sel_edge[1] << endl;
			picked_edges.emplace_back(sel_edge);
		}
		if (r < p_other) { //
			//int src = rand() % num_nodes;
			//int dst = rand() % num_nodes;

			int src = activity_discrete_dist(gen);
			int dst = activity_discrete_dist(gen);
			//cout << src << endl;
			//cout << dst << endl;
			while (src == dst) {
				dst = activity_discrete_dist(gen);
			};
			vector<int> sel_edge;
			sel_edge.emplace_back(src);
			sel_edge.emplace_back(dst);
			//if (I(i) + accu(E.col(i)) + I(dst) + accu(E.col(dst)) > 0) { // Only add if the involved agents are epidemiologically active
			//cout << "Adding edge " << sel_edge[0] << "<->" << sel_edge[1] << endl;
			picked_edges.emplace_back(sel_edge);
		}
	}
	// Routine for returning the coefficient of variation of the actual number of PICKED edges:
	bool getCoV = true;
	if (getCoV) {
		//cout << "[DEBUG] Total number of active edges: " << picked_edges.size() << endl;
		mat np(1,num_nodes,fill::zeros);
		for (int i = 0; i < picked_edges.size(); i++) {
			np(picked_edges[i][0]) += 1;
			np(picked_edges[i][1]) += 1;
		}
		// cout << "Coefficient of activity variation: " << stddev(a_vec,0,1)/mean(a_vec,1) << endl;
		//cout << "Coefficient of variation, active edges: " << stddev(np,0,1)/mean(np,1) << endl;
		//cout << "Mean: " << mean(np,1) << endl;
		//cout << "Mean: " << accu(np)/np.size() << endl;
		//cout << "Standard deviation: " << stddev(np,0,1) << endl;
	}
	return picked_edges;
}


vector<vector<int>> pick_edges(vector<vector<int>> edgelist, map<int, vector<int> >  neighbordict, int num_nodes, float p_own, float p_other, mat a_vec){
	vector<vector<int>> picked_edges;
	int num_edges_picked = 0;
	int num_edges_to_pick = int(accu(a_vec));
	random_device rd;
  	mt19937 gen(rd());
	int wasted = 0;
	while (num_edges_picked < num_edges_to_pick) {
		int i = rand() % num_nodes;
		poisson_distribution<int> d(a_vec[i]);
		int L = d(gen);
		//int L = round(a_vec[i]);
		//cout << L << endl;
		//cout << a_vec[i] << endl;
		//cout << "[DEBUG] Node " << i << " activates " << L << " edges:" << endl;
		int l = 0;
		int num_neigh = int(neighbordict[i].size());
		if (num_neigh == 0) {
			L = 0;
		}
		while (l < L) {
			wasted++;
			//BEG_a
			float r = randu();
			if (r < p_own) {
				if(!neighbordict[i].empty()){
					int ri = (rand() % num_neigh);
					int dst = neighbordict[i][ri];
					vector<int> sel_edge;
					sel_edge.push_back(i);
					sel_edge.push_back(dst);
					//if (I(i) + accu(E.col(i)) + I(dst) + accu(E.col(dst)) > 0) { // Only add if the involved agents are epidemiologically active
					if (a_vec[dst] >= a_vec[i]) {
						picked_edges.emplace_back(sel_edge);
						num_edges_picked++;
						l++;
						wasted--;
					}
					else {
						float q = randu();
						if (q < a_vec[dst]/a_vec[i]) {
							picked_edges.emplace_back(sel_edge);
							num_edges_picked++;
							l++;
							wasted--;
						}
					}
					//}
				}
			}
			if (r < p_other) {
				int dst = rand() % num_nodes;
				int src = i;
				while (src == dst) {
					dst = (rand() % num_nodes);
				};
				vector<int> sel_edge;
				sel_edge.emplace_back(src);
				sel_edge.emplace_back(dst);
				//if (I(i) + accu(E.col(i)) + I(dst) + accu(E.col(dst)) > 0) { // Only add if the involved agents are epidemiologically active
				if (a_vec[dst] >= a_vec[i]) {
					picked_edges.emplace_back(sel_edge);
					num_edges_picked++;
					l++;
				}
				else {
					float q = randu();
					if (q < a_vec[dst]/a_vec[i]) {
						picked_edges.emplace_back(sel_edge);
						num_edges_picked++;
						l++;
					}
				}
				//}
			}
			//END_a
		}
	}
	bool getCoV = true;
	if (getCoV) {
		mat np(1,num_nodes,fill::ones);
		for (int i = 0; i < picked_edges.size(); i++) {
			np(picked_edges[i][0])++;
			np(picked_edges[i][1])++;
		}
		// cout << "Coefficient of activity variation: " << stddev(a_vec,0,1)/mean(a_vec,1) << endl;
		//cout << "Coefficient of variation, active edges: " << stddev(np,0,1)/mean(np,1) << endl;
	}
	//cout << "[DEBUG] Total number of active edges: " << picked_edges.size() << endl;
	//cout << "[DEBUG] Wasted attempts: " << wasted << endl;
	return picked_edges;
}

auto sudden_vaccination(int n_users, umat S, umat R, float initrec, string vacc_scheme, mat a_vec, map<int, vector<int> > neighbordict) {
	umat S_to_R(1,n_users,fill::zeros);
	if (vacc_scheme == "vacc_random") {
	    cout << "Vaccinating following scheme: " << vacc_scheme << endl;
	    S_to_R = (mat(1,n_users,fill::randu) < initrec) % S;
	}
	else if (vacc_scheme == "vacc_active") {
	    cout << "Vaccinating following scheme: " << vacc_scheme << endl;
	    int n_vacc = int(n_users * initrec); // Number to vaccinate
	    umat s_idx = sort_index(a_vec, "descend");
	    for (int i=0; i < n_vacc; i++) {
	        S_to_R(s_idx(i)) = 1 * S(s_idx(i));
	    }
	}
	else if (vacc_scheme == "vacc_diverse") {
	    cout << "Vaccinating following scheme: " << vacc_scheme << endl;
	    int n_vacc = int(n_users * initrec); // Number to vaccinate
	    // First we must generate a vector of the diversity (number of distinct connections) of each person:
	    umat diversities(1,n_users,fill::zeros);
	    for (int i = 0; i < n_users; i++) {
	        diversities(i) += int(neighbordict[i].size());
	    }
	    // Then we get the sorting index, ranking users from most to least "diverse":
	    umat s_idx = sort_index(diversities, "descend");
	    // And then we vaccinate the first n_vacc of these:
	    for (int i=0; i < n_vacc; i++) {
	        S_to_R(s_idx(i)) = 1 * S(s_idx(i));
	    }
	}
	cout << "Total number initially vaccinated: " << accu(S_to_R) << endl;
	S = S - S_to_R;
	R = R + S_to_R;

	struct retVals {        // Declare a local structure
	    umat S; // For returning S
	    umat R; // For returning R
	};
	return retVals {S, R};
}

auto propagate_time(vector<vector<int>> edgelist, int tstep, umat S, umat E, umat I, umat R, Params parameters, int n_users, map<int, InfectionTree > infectree, map<int, vector<int> > R0tree, map<int, vector<int> > R0times, umat vars, mat var_pinf, mat var_alpha) {
	float I_to_R_rate = (7.0/10000) * parameters.dt/5.0;
	float E_to_next_rate = (29.0/10000) * parameters.dt/5.0;
	//cout << "Rates: " << "E: " << E_to_next_rate << " I: " << I_to_R_rate << endl;
	// Loop over edges
	for (int i = 0; i < edgelist.size(); i++) {
		//cout << edgelist[i][0]  << " meets " << edgelist[i][1] << endl;
		int u = edgelist[i][0];
		int su = edgelist[i][1];

		if (I[u] || I[su] || E(E.n_rows-1,u) || E(E.n_rows-1,su)) {
			bool su_exp_by_u = (randu() < parameters.p_infvec(u) * parameters.p_susvec(su));
			bool u_exp_by_su = (randu() < parameters.p_infvec(su) * parameters.p_susvec(u));
			//if ( (I[u] || E.row(E.n_rows-1)(u)) && S[su] ) {
			if ( (I[u] || E(E.n_rows-1,u)) && S[su] ) {
				if(su_exp_by_u) {
					S[su] = 0;
					E(0,su) = 1;
					infectree[su].t_infected = tstep;
					infectree[su].infected_by = u;
					infectree[u].users_infected.push_back(su);
					// An individual (su) is now infected
					// so we must assign a variant (inherited)
					// and an infectivity (drawn from distribution):
					vars[su] = vars[u];
					parameters.p_infvec[su] = draw_single_infectivity(var_pinf[vars[su]-1] , parameters.p_infdist, var_alpha[vars[su]-1], true);
				}
			}
			//else if ((I[su] || E.row(E.n_rows-1)(su)) && S[u])  {
			else if ((I[su] || E(E.n_rows-1,su)) && S[u])  {
				if(u_exp_by_su) {
					S[u] = 0;
					E(0,u) = 1;
					infectree[u].t_infected = tstep;
					infectree[u].infected_by = su;
					infectree[su].users_infected.push_back(u);
					// An individual (u) is now infected
					// so we must assign a variant (inherited)
					// and an infectivity (drawn from distribution):
					vars[u] = vars[su];
					parameters.p_infvec[u] = draw_single_infectivity(var_pinf[vars[u]-1] , parameters.p_infdist, var_alpha[vars[u]-1], true);
				}
			}
			if ((I[u] || E(E.n_rows-1,u)) && su_exp_by_u) {
				bool su_in_R0list = (std::find(R0tree[u].begin(), R0tree[u].end(), su) != R0tree[u].end());
				//bool su_in_infectee_list = (std::find(infectree[u].users_infected.begin(), infectree[u].users_infected.end(), su) != infectree[u].users_infected.end());
				if (su_in_R0list) {
					// Do nothing
				}
				else {
					R0tree[u].emplace_back(su);
					R0times[u].emplace_back(tstep);
				}
			}
			if ((I[su] || E(E.n_rows-1,su)) && u_exp_by_su) {
				bool u_in_R0list = (std::find(R0tree[su].begin(), R0tree[su].end(), u) != R0tree[su].end());
				//bool u_in_infectee_list = (std::find(infectree[su].users_infected.begin(), infectree[su].users_infected.end(), u) != infectree[su].users_infected.end());
				if (u_in_R0list) {
					// Do nothing
				}
				else {
					R0tree[su].emplace_back(u);
					R0times[su].emplace_back(tstep);
				}
			}
	};

	}

	for (int i = 0; i < n_users; i++) {
		if ((S[i]==0) && (R[i]==0)) {
			// Pass through the E-states:
			float r = randu();
			if (E(0,i) == 1) {
				if (r < E_to_next_rate) {
					//cout << "Agent " << i << " progressing from E0 to E1" << endl;
					//cout << "Before: E(0,i) = " << E(0,i) << endl;
					E(0,i) = 0;
					E(1,i) = 1;
					//cout << "After: E(0,i) = " << E(0,i) << endl;
				}
			}
			else if (E(1,i) == 1) {
				if (r < E_to_next_rate) {
					//cout << "Agent " << i << " progressing from E1 to P" << endl;
					E(1,i) = 0;
					E(2,i) = 1;
				}
			}
			// Go from P=E(2) to I:
			else if (E(2,i) == 1) {
				if (r < E_to_next_rate) {
					//cout << "Agent " << i << " progressing from P to I" << endl;
					E(2,i) = 0;
					I(i) = 1;
					infectree[i].t_symptom = tstep;
				}
			}
			// Some go from I to R:
			else if (I(i) == 1) {
				if (r < I_to_R_rate) {
					I(i) = 0;
					R(i) = 1;
					//cout << "Recovering after " << float(tstep-infectree[i].t_infected)/24.0 << " days." << endl;
				}
			}
		}
	}
	int v1_EI = accu( (vars==1) % (I + E.row(0) + E.row(1) + E.row(2) ));
	int v2_EI = accu( (vars==2) % (I + E.row(0) + E.row(1) + E.row(2) ));
	int v1_R = accu( (vars==1) % R);
	int v2_R = accu( (vars==2) % R);
	//cout << "S: " << accu(S) << endl;
	//cout << "I: " << accu(I) << endl;
	//cout << "R: " << accu(R) << endl;
	struct retVals {        // Declare a local structure
		umat S; // For returning S
		umat E; // For returning E
		umat I; // For returning I
		umat R; // For returning R
		map<int, InfectionTree > infectree;
		map<int, vector<int> > R0tree;
		map<int, vector<int> > R0times;
		umat vars;
		mat p_infvec;
		int var1_EI;
		int var2_EI;
		int var1_R;
		int var2_R;
	};
	return retVals {S, E, I, R, infectree, R0tree, R0times, vars, parameters.p_infvec, v1_EI, v2_EI, v1_R, v2_R}; // Return the local structure
}

// Function for returning strings of floats with higher precision
template <typename T>
std::string to_string_with_precision(const T a_value, const int n = 6)
{
    std::ostringstream out;
    out.precision(n);
    out << std::fixed << a_value;
    return out.str();
}

// Function for hashing, to get a "more unique" seed.
// http://www.concentric.net/~Ttwang/tech/inthash.htm
unsigned long mix(unsigned long a, unsigned long b, unsigned long c)
{
    a=a-b;  a=a-c;  a=a^(c >> 13);
    b=b-c;  b=b-a;  b=b^(a << 8);
    c=c-a;  c=c-b;  c=c^(b >> 13);
    a=a-b;  a=a-c;  a=a^(c >> 12);
    b=b-c;  b=b-a;  b=b^(a << 16);
    c=c-a;  c=c-b;  c=c^(b >> 5);
    a=a-b;  a=a-c;  a=a^(c >> 3);
    b=b-c;  b=b-a;  b=b^(a << 10);
    c=c-a;  c=c-b;  c=c^(b >> 15);
    return c;
}

int main(int argc, char **argv)
{
	cout << "Begin main()" << endl;
	unsigned long seed = mix(clock(), time(NULL), getpid());
	srand(seed);
	//srand((unsigned int)time(NULL));
	Params parameters;
	parameters.p_infdist = "gamma";
	parameters.alpha = 0.10;
	//parameters.dt = 5;
	parameters.dt = 30;
	//parameters.dt = 15;
	int timesteps_per_day = (60*24)/parameters.dt;
	parameters.n_users = 1000000;
	parameters.timesteps = timesteps_per_day * 400;
	//parameters.timesteps = 10;
	//parameters.timesteps = 206*100;
	//parameters.timesteps = 250;
	//parameters.timesteps = 500;
	parameters.networktype = "ER";
	parameters.avg_deg = 5;
	parameters.avg_deg_ER = 3; // Must be < avg_deg
	parameters.p_inf0 = 0.001 * 10;
	parameters.p_inf = 0.00017;
	parameters.p_own = 1.0;
	parameters.p_other = 0.0;
	parameters.basedir = "."; // Fallback value ...
	parameters.initrec = 0.0; // Fallback value
	// Fallback activity values:
	parameters.a_mean = 1.0;
	parameters.act_dist = "delta";
	parameters.alpha_act = 1.0;
	// Fallback susceptibility values
	parameters.p_susdist = "delta";
	parameters.alpha_sus = 1.0;
	// Vaccination parameter(s):
	parameters.vacc_scheme = "vacc_diverse";
	//parameters.p_inf = (0.6/1000.0) * parameters.dt/5.0;
	//parameters.p_inf = 0.29;
	/* Command line arguments:
	0: executable name
	1: p_inf
	2: alpha (the dispersion parameter also known as k)
	3: p_own (Fraction of contacts drawn from personal network)
	4: p_other (Fraction of contacts drawn randomly)
	5: networktype
	6: avg_deg (number of contacts per person (on average))
	7: avg_deg_ER, must be <= avg_deg
	8: p_infdist
	9: basedir
	10: R(t=0), immune/recovered fraction at t=0
	11: act_dist (social time distribution)
	12: alpha_act (dispersion parameter for social activity)
	13: p_susdist
	14: alpha_sus (dispersion parameter for social activity) */
	cout << "Command line arguments (in order): \n (0: executable name) \n 1: p_inf \n 2: alpha\n 3: p_own\n 4: p_other\n 5: networktype\n 6: avg_deg\n 7: avg_deg_ER\n 8: p_infdist." << endl;
	if (argc > 1) { // Set p_inf from command line, and more if argc > 2 as well.
		parameters.p_inf = stof(argv[1]) * parameters.dt;
		cout << "p_inf (passed via command line) = " << parameters.p_inf << endl;
		if (argc > 2) { // Set alpha from command line.
			parameters.alpha = stof(argv[2]);
			cout << "alpha (passed via command line) = " << parameters.alpha << endl;
			if (argc > 4) { // Set p_own and p_other from command line
				parameters.p_own = stof(argv[3]);
				parameters.p_other = stof(argv[4]);
				cout << "p_own:p_other (passed via command line) = " << parameters.p_own << ":" << parameters.p_other << endl;
				if (argc > 5) { // Set networktype from command line
					parameters.networktype = argv[5];
					cout << "Network type (passed via command line) = " << parameters.networktype << endl;
					if (argc > 6) { // Set avg_deg from command line
						parameters.avg_deg = stof(argv[6]);
						cout << "avg_deg (passed via command line) = " << parameters.avg_deg << endl;
						if (argc > 7) { // Set avg_deg_ER from command line. Must be < avg_deg.
							parameters.avg_deg_ER = stof(argv[7]);
							cout << "avg_deg_ER (passed via command line) = " << parameters.avg_deg_ER << endl;
							if (argc > 8) { // Set p_infdist from command line
								parameters.p_infdist = argv[8];
								cout << "Infectivity distribution (passed via command line) = " << parameters.p_infdist << endl;
								if (argc > 9) { // Set basedir from command line
									parameters.basedir = argv[9];
									cout << "Base directory (passed via command line) = " << parameters.basedir << endl;
									if (argc > 10) { // Set initial immune fraction from command line
										parameters.initrec = stof(argv[10]);
										cout << "Initial immune fraction (passed via command line) = " << parameters.initrec << endl;
										if (argc > 11) {
											parameters.act_dist = argv[11];
											cout << "Activity distribution (passed via command line) = " << parameters.act_dist << endl;
											if (argc > 12) {
												parameters.alpha_act = stof(argv[12]);
												cout << "Activity dispersion (passed via command line) = " << parameters.alpha_act << endl;
												if (argc > 13) {
													parameters.p_susdist = argv[13];
													cout << "Susceptibility distribution (passed via command line) = " << parameters.p_susdist << endl;
													if (argc > 14) {
														parameters.alpha_sus = stof(argv[14]);
														cout << "Susceptibility dispersion (passed via command line) = " << parameters.alpha_sus << endl;
													}
													else {
														cout << "Susceptibility dispersion (default value) = " << parameters.alpha_sus << endl;
													}
												}
												else {
													cout << "Susceptibility distribution (default value) = " << parameters.p_susdist << endl;
												}
											}
											else {
												cout << "Activity dispersion (default value) = " << parameters.alpha_act << endl;
											}
										}
										else {
											cout << "Activity distribution (default value) = " << parameters.act_dist << endl;
										}
									}
										else {
											cout << "Initial immune fraction (default value) = " << parameters.initrec << endl;
										}
									}
								else {
									cout << "Base directory (default value) = (" << parameters.basedir << ")" << endl;
								}
							}
							else {
								cout << "Infectivity distribution (default value) = " << parameters.p_infdist << endl;
							}
						}
						else {
							cout << "avg_deg_ER (default value) = " << parameters.avg_deg_ER << endl;
						}
					}
					else {
						cout << "avg_deg (default value) = " << parameters.avg_deg << endl;
					}
				}
				else {
					parameters.networktype = "ER";
					cout << "Network type (default value) = " << parameters.networktype << endl;
				}
			}
			else {
				cout << "p_own:p_other (default value) = " << parameters.p_own << ":" << parameters.p_other << endl;
			}
		}
		else {
			if (parameters.p_infdist == "gamma") {
				cout << "alpha (default value) = " << parameters.alpha << endl;
			}
		}
	}
	else {
		cout << "p_inf (default value) = " << parameters.p_inf << endl;
	}
	//string datadir = "data_other/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "/";
	//string datadir = "data_clustertest/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "/";
	//string datadir = "data_negbinom_full/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "/";
	//string datadir = "data_flat_conn/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "/";
	//string datadir = "data_gamma_conn/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "/";
	//string datadir = "data_gamma_ER_degree/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "/";
	//string datadir = "calibrate_pother_R0_3/data_k_" + to_string(int(parameters.avg_deg)) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "/";
	//string datadir = basedir + "data_vary_k/data_k_" + to_string(int(parameters.avg_deg)) + "_kER_" + to_string(parameters.avg_deg_ER) + "_pinf_" + to_string(int(100000*parameters.p_inf))  + "_dt_" + to_string(parameters.dt) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "_" + parameters.p_infdist + "/";
	string datadir = parameters.basedir + "/data_" + to_string(seed) + "_k_" + to_string(int(parameters.avg_deg)) + "_kER_" + to_string(int(parameters.avg_deg_ER)) + "_alpha_" + to_string(parameters.alpha) + "_pother_" + to_string(parameters.p_other) + "_" + parameters.networktype + "_infdist_" + parameters.p_infdist + "_actdist_" + parameters.act_dist + "/";
	cout << "Data directory: " << datadir << endl;
	boost::filesystem::create_directories(datadir);

	//parameters.p_inf = (2.5/1000.0) * parameters.dt/5.0;
	//parameters.p_inf = (1.45/1000.0) * parameters.dt/5.0;
	cout << "Generating infectivity distribution:" << endl;
	// First we need to use the information about variants and their parameters
	// I start by hardcoding two variants:
	mat var_alpha(1,2,fill::zeros);
	mat var_pinf(1,2,fill::zeros);
	mat var_fraction(1,2,fill::zeros); // Initial fraction of the infected population which is of each var.
	var_fraction[0]=0.99;
	var_fraction[1]=1.0-var_fraction[0];
	var_alpha[0] = 0.1;
	var_alpha[1] = 0.2;
	var_pinf[0] = parameters.p_inf;
	var_pinf[1] = parameters.p_inf;
	parameters.a_vec = generate_activities(parameters.n_users, parameters.a_mean, parameters.act_dist, parameters.alpha_act);
	//vector<tuple<int, int>> g = gen_ER(N, M, true);
	//vector<tuple<int, int>> g, map<int, vector<int> > neighbordict = gen_ER(N, M);

	Edgelist_and_neighbordict el_and_nd;

	if (parameters.networktype == "ER") {
		el_and_nd = gen_ER(parameters.n_users, int(parameters.avg_deg * parameters.n_users/2.0));
	}
	else if (parameters.networktype == "exp") {
		cout << "Generating exponential network ... " << endl;
		el_and_nd = gen_exp_network(parameters.n_users, parameters.avg_deg);
	}
	else if (parameters.networktype == "power") {
		cout << "Generating scale-free network ... " << endl;
		el_and_nd = gen_pow_network(parameters.n_users, parameters.avg_deg);
	}
	else if (parameters.networktype == "groups") {
		cout << "Generating groups network ... " << endl;
		el_and_nd = generate_groups_network(parameters.n_users, parameters.avg_deg, 2);
	}
	else {
		cout << "Generating cluster network ... " << endl;
		el_and_nd = gen_clusternet(parameters.n_users, int(parameters.avg_deg * parameters.n_users/2.0), int(parameters.avg_deg_ER * parameters.n_users/2.0));
	}
	vector<vector<int>> g = el_and_nd.el;
	map<int, vector<int> > neighbordict = el_and_nd.nd;
	cout << "Network generated" << endl;
	//auto neighbordict = gen_ER(N, M);
	//cout << neighbordict[0][0] << endl;
	int degsum = 0;
	int neighborless = 0;
	for (int i = 0; i < parameters.n_users; i++) {
		//print_intvec(neighbordict[i]);
		degsum += neighbordict[i].size();
		if (neighbordict[i].size() == 0) {
			neighborless++;
		}
	};
	cout << "Average node degree (measured): " << float(degsum)/(float(parameters.n_users)) << endl;
	cout << "Number of neighborless individuals: " << neighborless << endl;

	auto [S_t, E_t, I_t, R_t, S, E, I, R, vars, infvec_loc , infectree, R0tree, R0times, var1_EI_t, var2_EI_t, var1_R_t, var2_R_t] = init_arrs(neighbordict, parameters.timesteps, parameters.n_users, var_alpha, var_pinf, var_fraction, parameters.p_infdist, parameters.p_inf0, parameters.initrec, parameters.a_vec, parameters.vacc_scheme);
	parameters.p_infvec = infvec_loc;
	cout << "Generating susceptibility distribution:" << endl;
	parameters.p_susvec = generate_susceptibilities(parameters.n_users, mat(1,parameters.n_users,fill::ones), parameters.p_susdist, parameters.alpha_sus*mat(1,parameters.n_users,fill::ones), false);
	float max_inf_sus_product = (parameters.p_infvec * parameters.p_susvec.max()).max();
	float number_of_exceeds = accu(parameters.p_infvec * parameters.p_susvec.max() > 1);
	if (number_of_exceeds > 0) {
		cout << endl << "-----WARNING-----" << endl;
		cout << "Infection probability exceeds 1." << endl;
		cout << "Number of violations: " << number_of_exceeds << endl;
		cout << "Maximum p_inf * p_sus " << max_inf_sus_product << endl;
	}

	//cout << S_t.row(0) << endl;
	cout << "Starting simulation with infectivity distribution: " << parameters.p_infdist << endl;
	vector<vector<int>> picked_edges;
	bool NPI_triggered = false;
	for (int i = 1; i < parameters.timesteps; i++) {
		int var1_EI = var1_EI_t(i-1);
		int var2_EI = var2_EI_t(i-1);
		int var1_R = var1_R_t(i-1);
		int var2_R = var2_R_t(i-1);
		if (i % 50 == 0 || i == 1) {
			cout << "Timestep: " << i << endl;
			int E_plus_I = (accu(E) + accu(I));
			cout << "E+I: " << E_plus_I << endl;
			cout << "R: " << accu(R) << endl;
			cout << "I(1)/I: " << float(accu( (vars==1) % I))/float(accu(I)) << endl;
			cout << "R(1)/R: " << float(accu( (vars==1) % R))/float(accu(R))  << endl;
		}
		if ((accu(E) + accu(I)) > 0 ) {
			if (i % 2 == 0 || i == 1) { // Do not pick new active edges _every_ timestep, since activity allows for multiple simultaneously active, anyway.
				picked_edges = pick_edges(g, neighbordict, parameters.n_users, parameters.p_own, parameters.p_other, parameters.a_vec);
			}
			auto [S_new, E_new, I_new, R_new, infectree_new, R0tree_new, R0times_new, vars_new, pinfvec_new, var1_EI_new, var2_EI_new, var1_R_new, var2_R_new	] = propagate_time(picked_edges, i, S, E, I, R, parameters, parameters.n_users, infectree, R0tree, R0times, vars, var_pinf, var_alpha);
			S = S_new;
			E = E_new;
			I = I_new;
			R = R_new;
			var1_EI = var1_EI_new;
			var2_EI = var2_EI_new;
			var1_R = var1_R_new;
			var2_R = var2_R_new;
			infectree = infectree_new;
			R0tree = R0tree_new;
			R0times = R0times_new;
			vars = vars_new;
			parameters.p_infvec = pinfvec_new;
			bool trigger_NPI;
			/* Two scenarios: Either we trigger an NPI when a certain fraction has been
			infected, or we do it when a certain amount of time has elapsed. */
			trigger_NPI = (var2_EI/(var2_EI+var1_EI+0.001) >= 0.2);
			/* i_trig is the timestep at which to trigger an NPI */
			//int i_trig = timesteps_per_day * 25;
			//int i_trig = timesteps_per_day * 35;
			//trigger_NPI = (i == i_trig);
			if (trigger_NPI && !NPI_triggered) {
				NPI_triggered = true;
				// If it is time to lift some restrictions:
				// The last argument determines the increase in connectivity as follows:
				// if argument is n*parameters.n_users, connecitivity increases by 2n
				//auto [g_new, neighbordict_new] = enlarge_ER_network(g, neighbordict, parameters.n_users, 5*parameters.n_users);
				//g = g_new;
				//neighbordict = neighbordict_new;
				// A more extreme intervention: Going well-mixed
				parameters.p_other = 1.0;
				parameters.p_own = 0.0;
				//cout << "Restrictions lifted!" << endl;
				// Something else entirely: Sudden vaccination!
				//cout << "Sudden vaccination!" << endl;
				//auto [S_vacc, R_vacc] = sudden_vaccination(parameters.n_users, S, R, 0.4, "vacc_random", parameters.a_vec, neighbordict);
				//S = S_vacc;
				//R = R_vacc;
				//cout << "NOT! Sudden vaccination!" << endl;
				// *** Here we try a combined event, namely lifting restrictions on sizes of gatherings (network size 10 -> 50)
				// *** while simultaneously decreasing the overall "social time", which is analogous to decreasing the risk of
				// *** infection per encounter, so it could be used as a proxy for e.g. mask wearing or social distancing.
				// First we draw new contact networks
				//auto [g_new, neighbordict_new] = enlarge_ER_network(g, neighbordict, parameters.n_users, 20*parameters.n_users);
				//g = g_new;
				//neighbordict = neighbordict_new;
				// Next we decrease the social activity (transmission-relevant social time).
				// We begin by halving it:
				//parameters.a_vec *= 0.75; // In-place multiplication
				cout << "Event triggered at timestep " << i << "." << endl;
				//cout << "Social networks enlarged from 10 to 50." << endl;
				//cout << "Social time decreased to 50%." << endl;
				cout << "Homogenizing contact structure!" << endl;
				cout << "---**---------------------------**---" << endl;
				}
			}
		S_t(i) = accu(S);
		E_t(i) = accu(E);
		I_t(i) = accu(I);
		R_t(i) = accu(R);
		var1_EI_t(i) = var1_EI;
		var2_EI_t(i) = var2_EI;
		var1_R_t(i) = var1_R;
		var2_R_t(i) = var2_R;
		//cout << "S_t(t): " <<  S_t(i) << endl;
		// Periodically, output S, E, I, R and variant information:
		if (i % 400 == 0) {
			// Output S:
			cout << "Saving matrices ... ";
			S_t.save(datadir + "S.dat", csv_ascii);
			// Output E:
			E_t.save(datadir + "E.dat", csv_ascii);
			// Output I:
			I_t.save(datadir + "I.dat", csv_ascii);
			// Output R:
			R_t.save(datadir + "R.dat", csv_ascii);
			// Output var1_EI, var2_EI, var1_R, var2_R:
			var1_EI_t.save(datadir + "var1_EI.dat", csv_ascii);
			var2_EI_t.save(datadir + "var2_EI.dat", csv_ascii);
			var1_R_t.save(datadir + "var1_R.dat", csv_ascii);
			var2_R_t.save(datadir + "var2_R.dat", csv_ascii);
			cout << "Matrices saved." << endl;
		}
	};
	cout << "Simulation done." << endl;
	// Output edgelist:
	/*std::ofstream ofs_edgelist(datadir + "edgelist.dat");
	boost::archive::text_oarchive oa_edgelist(ofs_edgelist);
	oa_edgelist << g;*/
	cout << "Type of exported data:" << typeid(g).name() << endl;
	// Output neighbordict:
	std::ofstream ofs_neighbordict(datadir + "neighbordict.dat");
	boost::archive::text_oarchive oa_neighbordict(ofs_neighbordict);
	oa_neighbordict << neighbordict;
	cout << "Type of exported data: " << typeid(neighbordict).name() << endl;
	// Output infectree:
	ofstream infectree_file;
	infectree_file.open (datadir + "infectree.dat");
	for (int i = 0; i < parameters.n_users; i++) {
		string outstr = "";
		outstr.append(to_string(i) + " ");
		outstr.append(to_string(infectree[i].t_infected) + " ");
		outstr.append(to_string(infectree[i].t_symptom) + " ");
		outstr.append(to_string(infectree[i].infected_by) + " ");
		for (int j = 0; j < infectree[i].users_infected.size(); j++) {
			outstr.append(to_string(infectree[i].users_infected[j]) + " ");
		}
		outstr.append("\n");
		infectree_file << outstr;
	}
	infectree_file.close();
	cout << "Type of exported data: " << typeid(infectree).name() << endl;
	// Output edgelist:
	// vector<vector<int>> edgelist
	ofstream edgelist_file;
	edgelist_file.open (datadir + "edgelist.dat");
	for (int i = 0; i < g.size(); i++) {
			string outstr = "";
			outstr.append(to_string(g[i][0] ) + " ");
			outstr.append(to_string(g[i][1] ));
			outstr.append("\n");
			edgelist_file << outstr;
	}
	edgelist_file.close();
	// Output final picked_edges:
	ofstream pe_file;
	pe_file.open (datadir + "picked_edges.dat");
	for (int i = 0; i < picked_edges.size(); i++) {
			string outstr = "";
			outstr.append(to_string(picked_edges[i][0] ) + " ");
			outstr.append(to_string(picked_edges[i][1] ));
			outstr.append("\n");
			pe_file << outstr;
	}
	pe_file.close();
	// Output R0tree:
	ofstream R0tree_file;
	R0tree_file.open (datadir + "R0tree.dat");
	for (int i = 0; i < parameters.n_users; i++) {
		// Two options: Add only those who have actually been infectious,
		// or just add all and use the information from infectree to discern.
		//if (infectree[i].t_infected >= 0) {
		if (1) {
			string outstr = "";
			outstr.append(to_string(i) + " ");
			for (int j = 0; j < R0tree[i].size(); j++) {
				outstr.append(to_string(R0tree[i][j]) + " ");
			}
			outstr.append("\n");
			R0tree_file << outstr;
		}
	}
	R0tree_file.close();
	// Output R0times:
	ofstream R0times_file;
	R0times_file.open (datadir + "R0times.dat");
	for (int i = 0; i < parameters.n_users; i++) {
		// Two options: Add only those who have actually been infectious,
		// or just add all and use the information from infectree to discern.
		//if (infectree[i].t_infected >= 0) {
		if (1) {
			string outstr = "";
			outstr.append(to_string(i) + " ");
			for (int j = 0; j < R0times[i].size(); j++) {
				outstr.append(to_string(R0times[i][j]) + " ");
			}
			outstr.append("\n");
			R0times_file << outstr;
		}
	}
	R0times_file.close();
	// Output p_infvec:
	ofstream pinfvec_file;
	pinfvec_file.open(datadir + "p_infvec.dat");
	for (int i = 0; i < parameters.n_users; i++) {
		string outstr = "";
		outstr.append(to_string(i) + " ");
		//outstr.append(to_string(parameters.p_infvec(i)) + "\n");
		outstr.append(to_string_with_precision(parameters.p_infvec(i), 20) + "\n");
		pinfvec_file << outstr;
	}
	pinfvec_file.close();
	// Output p_susvec:
	ofstream psusvec_file;
	psusvec_file.open(datadir + "p_susvec.dat");
	for (int i = 0; i < parameters.n_users; i++) {
		string outstr = "";
		outstr.append(to_string(i) + " ");
		//outstr.append(to_string(parameters.p_susvec(i)) + "\n");
		outstr.append(to_string_with_precision(parameters.p_susvec(i), 20) + "\n");
		psusvec_file << outstr;
	}
	psusvec_file.close();
	// Output a_vec:
	ofstream actvec_file;
	actvec_file.open(datadir + "actvec.dat");
	for (int i = 0; i < parameters.n_users; i++) {
		string outstr = "";
		outstr.append(to_string(i) + " ");
		//outstr.append(to_string(parameters.a_vec(i)) + "\n");
		outstr.append(to_string_with_precision(parameters.a_vec(i), 20) + "\n");
		actvec_file << outstr;
	}
	pinfvec_file.close();
	// Output parameters:
	/*struct Params {
		int n_users;
		float p_inf;
		mat p_infvec;
		float p_inf0;
		float avg_deg;
		int dt;
		int timesteps;
		float p_own;
		float p_other;
	}; */
	ofstream params_file;
	params_file.open (datadir + "parameters.dat");
	string outstr = "";
	outstr.append(string("n_users") + " ");
	outstr.append(to_string(parameters.n_users) + "\n");
	outstr.append(string("p_inf") + " ");
	outstr.append(to_string(parameters.p_inf) + "\n");
	outstr.append(string("p_inf0") + " ");
	outstr.append(to_string(parameters.p_inf0) + "\n");
	outstr.append(string("avg_deg") + " ");
	outstr.append(to_string(parameters.avg_deg) + "\n");
	outstr.append(string("avg_deg_ER") + " ");
	outstr.append(to_string(parameters.avg_deg_ER) + "\n");
	outstr.append(string("dt") + " ");
	outstr.append(to_string(parameters.dt) + "\n");
	outstr.append(string("timesteps") + " ");
	outstr.append(to_string(parameters.timesteps) + "\n");
	outstr.append(string("p_own") + " ");
	outstr.append(to_string(parameters.p_own) + "\n");
	outstr.append(string("p_other") + " ");
	outstr.append(to_string(parameters.p_other) + "\n");
	outstr.append(string("alpha") + " ");
	outstr.append(to_string(parameters.alpha) + "\n");
	outstr.append(string("networktype") + " ");
	outstr.append(parameters.networktype + "\n");
	outstr.append(string("p_infdist") + " ");
	outstr.append(parameters.p_infdist  + "\n");
	outstr.append(string("initrec") + " ");
	outstr.append(to_string(parameters.initrec) + "\n");
	// Activity:
	outstr.append(string("a_mean") + " ");
	outstr.append(to_string(parameters.a_mean) + "\n");
	outstr.append(string("alpha_act") + " ");
	outstr.append(to_string(parameters.alpha_act) + "\n");
	outstr.append(string("act_dist") + " ");
	outstr.append(parameters.act_dist + "\n");
	// Susceptibility:
	outstr.append(string("p_susdist") + " ");
	outstr.append(parameters.p_susdist + "\n");
	outstr.append(string("alpha_sus") + " ");
	outstr.append(to_string(parameters.alpha_sus));
	params_file << outstr;
	params_file.close();

	// Output S:
	cout << "S(end): " <<  S_t(parameters.timesteps-1) << endl;
	bool S_t_save = S_t.save(datadir + "S.dat", csv_ascii);
	cout << "Exit status of S_t.save(): " << S_t_save << endl;
	cout << "Type of exported data: " << typeid(S_t).name() << endl;
	// Output E:
	bool E_t_save = E_t.save(datadir + "E.dat", csv_ascii);
	cout << "Exit status of E_t.save(): " << E_t_save << endl;
	cout << "Type of exported data: " << typeid(E_t).name() << endl;
	// Output I:
	I_t.save(datadir + "I.dat", csv_ascii);
	cout << "Type of exported data: " << typeid(I_t).name() << endl;
	// Output R:
	R_t.save(datadir + "R.dat", csv_ascii);
	cout << "Type of exported data: " << typeid(R_t).name() << endl;
	// Output var1_EI, var2_EI, var1_R, var2_R:
	var1_EI_t.save(datadir + "var1_EI.dat", csv_ascii);
	var2_EI_t.save(datadir + "var2_EI.dat", csv_ascii);
	var1_R_t.save(datadir + "var1_R.dat", csv_ascii);
	var2_R_t.save(datadir + "var2_R.dat", csv_ascii);
	return 0;
}
